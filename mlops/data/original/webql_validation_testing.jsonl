{"instruction": "How to test if a WebQL XPath selector is correct?", "input": "I want to verify my XPath works before running the full query", "output": "Test XPath selectors in browser dev tools:\n\n**Method 1 - Browser Console**:\n1. Open target website\n2. Press F12 (dev tools)\n3. Console tab\n4. Type: `$x(\"//your-xpath-here\")`\n5. Press Enter\n\n**Example**:\n```javascript\n$x(\"//div[@class='product']\")\n$x(\"//div[@class='product']//h3/text()\")\n```\n\n**Method 2 - Elements Inspector**:\n1. Right-click element → Inspect\n2. Ctrl+F in Elements panel\n3. Type your XPath\n4. See matches highlighted\n\n**WebQL Testing**:\n```json\n{\n  \"@url\": \"https://example.com\",\n  \"@steps\": [\n    {\n      \"@xpath\": \"//div[@class='product']\",  // Test this first\n      \"@fields\": {\n        \"name\": \".//h3/text()\"  // Then test this\n      }\n    }\n  ]\n}\n```"}
{"instruction": "How to validate WebQL query syntax?", "input": "Check if my WebQL JSON structure is correct", "output": "Validate WebQL syntax with these checks:\n\n**Required Structure**:\n✅ @url (string) - Target website\n✅ @steps (array) - Extraction steps\n✅ Each step has @xpath (string)\n✅ Each step has @fields (object)\n\n**Valid WebQL Template**:\n```json\n{\n  \"@url\": \"https://example.com\",\n  \"@steps\": [\n    {\n      \"@xpath\": \"//element-selector\",\n      \"@fields\": {\n        \"field_name\": \".//relative-xpath\"\n      }\n    }\n  ]\n}\n```\n\n**Common Syntax Errors**:\n❌ Missing @ prefixes\n❌ Steps not in array []\n❌ Absolute XPath in @fields (use relative .)\n❌ Missing quotes around keys/values\n❌ Single quotes instead of double quotes\n\n**Validation Command**:\n```bash\ndr-web-engine -q query.json5 --validate-only\n```"}
{"instruction": "How to run WebQL queries with debugging?", "input": "I want to see what's happening during extraction", "output": "Debug WebQL execution with these commands:\n\n**Basic Debug Logging**:\n```bash\ndr-web-engine -q query.json5 -o results.json -l debug\n```\n\n**Save Debug to File**:\n```bash\ndr-web-engine -q query.json5 -o results.json -l debug --log-file debug.log\n```\n\n**Debug with Browser Visible**:\n```bash\ndr-web-engine -q query.json5 -o results.json -l debug --no-headless\n```\n\n**Debug Information Shows**:\n- XPath selector matches\n- Element count found\n- Field extraction results\n- Page navigation steps\n- Action execution status\n- Error messages and stack traces\n\n**Progressive Debugging**:\n1. Start with simple @xpath only\n2. Add one @field at a time\n3. Test each step incrementally\n4. Add @actions when basic extraction works"}
{"instruction": "How to verify WebQL results are correct?", "input": "Check if extracted data matches what I expect", "output": "Verify WebQL extraction results:\n\n**Output Inspection**:\n```bash\n# Run extraction\ndr-web-engine -q query.json5 -o results.json\n\n# Check results\ncat results.json | jq '.' # Pretty print JSON\ncat results.json | jq 'length' # Count items\ncat results.json | jq '.[0]' # First item\n```\n\n**Manual Verification**:\n1. Compare extracted data with source webpage\n2. Check field completeness (no empty values)\n3. Verify data types match expectations\n4. Count extracted items vs expected\n\n**Common Issues**:\n- Empty results → XPath selector wrong\n- Partial data → Missing relative path (.) in @fields\n- Wrong data → XPath selecting wrong elements\n- Duplicates → XPath too broad\n\n**Test Query Structure**:\n```json\n{\n  \"@url\": \"https://quotes.toscrape.com\",\n  \"@steps\": [\n    {\n      \"@xpath\": \"//div[@class='quote']\",\n      \"@fields\": {\n        \"text\": \".//span[@class='text']/text()\",\n        \"author\": \".//small[@class='author']/text()\"\n      }\n    }\n  ]\n}\n```"}
{"instruction": "What are WebQL performance best practices?", "input": "How to make WebQL queries run faster and more reliably", "output": "WebQL performance optimization:\n\n**XPath Efficiency**:\n- Use specific selectors: `//div[@class='product']` not `//div`\n- Avoid descendant axis when possible: `.//h3` vs `.//*/h3`\n- Use attribute filters: `//a[@class='link']` not `//a[contains(@class,'link')]`\n\n**Query Structure**:\n- Minimize @follow depth: `@max-depth: 2` not unlimited\n- Use pagination limits: `@limit: 10` not 1000s\n- Add timeouts: `@timeout: 5000` for slow sites\n\n**Actions Optimization**:\n```json\n{\n  \"@actions\": [\n    {\n      \"@type\": \"wait\",\n      \"@until\": \"network-idle\",  // Wait for all content\n      \"@timeout\": 10000\n    }\n  ]\n}\n```\n\n**Resource Management**:\n- Use headless mode: `--xvfb` for servers\n- Limit concurrent requests\n- Add delays for rate limiting\n- Cache results when possible\n\n**Error Handling**:\n- Add fallback XPath: `.//h3/text() | .//h2/text()`\n- Use conditional extraction: `@if/@then/@else`\n- Validate required fields exist"}
{"instruction": "How to test WebQL queries on different websites?", "input": "Adapt my query to work across multiple similar sites", "output": "Test WebQL across multiple websites:\n\n**Flexible XPath Patterns**:\n```json\n{\n  \"@xpath\": \"//div[contains(@class,'product') or contains(@class,'item')]\",\n  \"@fields\": {\n    \"title\": \".//h3/text() | .//h2/text() | .//h1/text()\",\n    \"price\": \".//span[contains(@class,'price')]/text() | .//div[contains(@class,'cost')]/text()\"\n  }\n}\n```\n\n**Testing Strategy**:\n1. Identify common patterns across sites\n2. Use broad selectors with fallbacks\n3. Test on 3-5 similar websites\n4. Refine XPath for maximum compatibility\n\n**Site-Specific Variations**:\n```json\n{\n  \"@url\": \"https://site1.com OR site2.com OR site3.com\",\n  \"@steps\": [\n    {\n      \"@if\": {\"@url-contains\": \"site1.com\"},\n      \"@then\": [{\"@xpath\": \"//div[@class='product-site1']\"}],\n      \"@else\": [{\"@xpath\": \"//div[@class='product-general']\"}]\n    }\n  ]\n}\n```\n\n**Cross-Site Testing**:\n```bash\n# Test multiple URLs\ndr-web-engine -q query.json5 --url https://site1.com -o results1.json\ndr-web-engine -q query.json5 --url https://site2.com -o results2.json\n```"}
{"instruction": "How to handle WebQL extraction errors?", "input": "My query fails or returns empty results", "output": "WebQL error troubleshooting:\n\n**Common Error Types**:\n\n**1. Empty Results**:\n```bash\n# Debug XPath\ndr-web-engine -q query.json5 -l debug\n# Check if elements exist: [] vs null\n```\n\n**2. Timeout Errors**:\n```json\n{\n  \"@actions\": [\n    {\n      \"@type\": \"wait\",\n      \"@until\": \"element\",\n      \"@selector\": \".content\",\n      \"@timeout\": 15000  // Increase timeout\n    }\n  ]\n}\n```\n\n**3. XPath Syntax Errors**:\n- Check quotes: `[@class='item']` not `[@class=item]`\n- Use relative paths in @fields: `.//h3` not `//h3`\n- Escape special characters in text matching\n\n**4. Dynamic Content Issues**:\n```json\n{\n  \"@actions\": [\n    {\n      \"@type\": \"wait\",\n      \"@until\": \"network-idle\",  // Wait for AJAX\n      \"@timeout\": 10000\n    }\n  ]\n}\n```\n\n**Error Recovery**:\n- Use fallback XPath with | operator\n- Add @if/@else conditional logic\n- Implement retry mechanisms\n- Validate results before saving"}
{"instruction": "How to create robust WebQL queries?", "input": "Make queries that work reliably across different page layouts", "output": "Create robust WebQL queries:\n\n**Fallback Selectors**:\n```json\n{\n  \"@xpath\": \"//div[@class='product'] | //article[@class='item'] | //section[contains(@class,'product')]\",\n  \"@fields\": {\n    \"title\": \".//h3/text() | .//h2/text() | .//h1/text() | .//span[@class='title']/text()\",\n    \"price\": \".//span[contains(@class,'price')]/text() | .//div[contains(@class,'cost')]/text() | .//*[contains(text(),'$')]/text()\"\n  }\n}\n```\n\n**Conditional Extraction**:\n```json\n{\n  \"@if\": {\"@exists\": \".sale-price\"},\n  \"@then\": [\n    {\"@fields\": {\"price\": \".//span[@class='sale-price']/text()\"}}\n  ],\n  \"@else\": [\n    {\"@fields\": {\"price\": \".//span[@class='regular-price']/text()\"}}\n  ]\n}\n```\n\n**Error-Tolerant Patterns**:\n- Use `contains()` instead of exact matches\n- Multiple XPath alternatives with `|`\n- Text normalization: `normalize-space(.)`\n- Attribute existence checks: `[@href]`\n\n**Validation Checks**:\n```json\n{\n  \"@fields\": {\n    \"title\": \".//h3[text()]/text()\",  // Only if text exists\n    \"link\": \".//a[@href]/@href\",      // Only if href exists\n    \"image\": \".//img[@src]/@src\"      // Only if src exists\n  }\n}\n```"}
{"instruction": "How to validate WebQL query performance?", "input": "Measure and optimize query execution time", "output": "Measure WebQL performance:\n\n**Timing Commands**:\n```bash\n# Basic timing\ntime dr-web-engine -q query.json5 -o results.json\n\n# Detailed timing with debug\ndr-web-engine -q query.json5 -o results.json -l debug --timing\n```\n\n**Performance Metrics**:\n- Page load time\n- XPath execution time\n- Element count processed\n- Data extraction time\n- Total query duration\n\n**Optimization Strategies**:\n\n**1. Limit Scope**:\n```json\n{\n  \"@pagination\": {\"@limit\": 5},  // Don't process 1000s of pages\n  \"@follow\": {\"@max-depth\": 2}   // Limit link following\n}\n```\n\n**2. Efficient XPath**:\n```json\n{\n  \"@xpath\": \"//div[@class='product'][position() <= 10]\",  // First 10 only\n  \"@fields\": {\n    \"title\": \".//h3[1]/text()\"  // First h3 only\n  }\n}\n```\n\n**3. Smart Waiting**:\n```json\n{\n  \"@actions\": [\n    {\n      \"@type\": \"wait\",\n      \"@until\": \"element\",\n      \"@selector\": \".product:nth-child(5)\",  // Wait for 5th item\n      \"@timeout\": 5000\n    }\n  ]\n}\n```\n\n**Performance Testing**:\n```bash\n# Test different limits\ndr-web-engine -q query.json5 --pagination-limit 5 -o test1.json\ndr-web-engine -q query.json5 --pagination-limit 10 -o test2.json\n```"}